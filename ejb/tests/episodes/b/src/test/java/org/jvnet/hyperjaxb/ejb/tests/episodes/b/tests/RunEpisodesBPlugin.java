package org.jvnet.hyperjaxb.ejb.tests.episodes.b.tests;

import static com.sun.tools.xjc.Language.XMLSCHEMA;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import org.apache.maven.artifact.factory.DefaultArtifactFactory;
import org.apache.maven.model.Dependency;
import org.apache.maven.project.MavenProject;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.jvnet.hyperjaxb.mojo.HyperjaxbMojo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Run HyperJAXB Mojo to generate Episode B entities.
 */
public class RunEpisodesBPlugin
{
	private Logger log = LoggerFactory.getLogger(RunEpisodesBPlugin.class);

	/**
	 * Validate the generation of a java files from src/main/resources/schema.xsd.
	 */
	@Test
	@Disabled
	public void testExecute() throws Exception
	{
		final HyperjaxbMojo mojo = new HyperjaxbMojo();
		
		mojo.setProject(new MavenProject());
		mojo.setSchemaDirectory(getDirectory("src/main/resources"));
		mojo.setSchemaIncludes(new String[] { "*.xsd" });
		mojo.setBindingIncludes(new String[] { "*.xjb" });
		mojo.setGenerateDirectory(getDirectory("target/generated-test-sources/xjc"));
		mojo.setArgs(getArgs());
		mojo.setVerbose(true);
		mojo.setDebug(true);
		mojo.setWriteCode(true);
		mojo.setRemoveOldOutput(true);
		mojo.setForceRegenerate(false);
		mojo.setExtension(true);
		mojo.setVariant("ejb");
		mojo.setSchemaLanguage(XMLSCHEMA.name());
		
		// mojo.setRoundtripTestClassName(getClass().getPackage().getName() + ".RoundtripTest");

		// TODO: Possible implement ArtifactFactory and Artifact interfaces with
		//       mockups?
		mojo.setArtifactFactory(new DefaultArtifactFactory());
//		mojo.setArtifactFactory(new ProjectArtifactFactory());
//		mojo.setArtifactResolver(null);
//		mojo.setLocalRepository(null);
//		mojo.setArtifactMetadataSource(null);
		
		// An "META-INF/sun-jaxb.episode" file is generated by the XJC (XML Schema to Java) compiler.
		// It is a schema bindings that associates schema types with existing classes.
		// It is useful when you have one XML schema that is imported by other schemas,
		// as it prevents the model from being regenerated.
		// XJC will scan JARs for '*.episode files', then use them as binding files automatically.
		final Dependency episode = new Dependency();
		episode.setGroupId("org.patrodyne.jvnet");
		episode.setArtifactId("hisrc-hyperjaxb-ejb-tests-episodes-a");
		episode.setVersion("0.6.5-SNAPSHOT");
		mojo.setEpisodes(new Dependency[] { episode });

		mojo.execute();
		log.info("Executed " + mojo);
	}
	
	private File getDirectory(String path)
	{
		return new File(getBaseDir(), path);
	}

	private List<String> getArgs()
	{
		List<String> args = new ArrayList<>();
		return args;
	}

	private File getBaseDir()
	{
		try
		{
			return (new File(RunEpisodesBPlugin.class.getProtectionDomain()
				.getCodeSource().getLocation().getFile())).getParentFile()
				.getParentFile().getAbsoluteFile();
		}
		catch (Exception ex)
		{
			throw new AssertionError(ex);
		}
	}
}
